% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spd-matrices.R
\name{SPDMatrices}
\alias{SPDMatrices}
\title{Manifold of Symmetric Positive Definite Matrices}
\description{
Class for the manifold of symmetric positive definite (SPD)
matrices.
}
\examples{

## ------------------------------------------------
## Method `SPDMatrices$new`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  spdm
}

## ------------------------------------------------
## Method `SPDMatrices$belongs`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  A <- diag(1, 3)
  spdm$belongs(A)
  B <- diag(-1, 3)
  spdm$belongs(B)
}

## ------------------------------------------------
## Method `SPDMatrices$cholesky_factor`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$cholesky_factor(A)
}

## ------------------------------------------------
## Method `SPDMatrices$differential_cholesky_factor`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_cholesky_factor(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$differential_exp`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_exp(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$differential_log`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_log(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$differential_power`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_power(2, diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$expm`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  spdm$expm(diag(-1, 3))
}

## ------------------------------------------------
## Method `SPDMatrices$logm`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  spdm$logm(diag(1, 3))
}

## ------------------------------------------------
## Method `SPDMatrices$inverse_differential_exp`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$inverse_differential_exp(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$inverse_differential_log`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$inverse_differential_log(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$inverse_differential_power`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$inverse_differential_power(2, diag(1, 3), A)
}
}
\author{
Yann Thanwerdas
}
\concept{discretized curves space}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-SPDMatrices-new}{\code{SPDMatrices$new()}}
\item \href{#method-SPDMatrices-belongs}{\code{SPDMatrices$belongs()}}
\item \href{#method-SPDMatrices-cholesky_factor}{\code{SPDMatrices$cholesky_factor()}}
\item \href{#method-SPDMatrices-differential_cholesky_factor}{\code{SPDMatrices$differential_cholesky_factor()}}
\item \href{#method-SPDMatrices-differential_exp}{\code{SPDMatrices$differential_exp()}}
\item \href{#method-SPDMatrices-differential_log}{\code{SPDMatrices$differential_log()}}
\item \href{#method-SPDMatrices-differential_power}{\code{SPDMatrices$differential_power()}}
\item \href{#method-SPDMatrices-expm}{\code{SPDMatrices$expm()}}
\item \href{#method-SPDMatrices-logm}{\code{SPDMatrices$logm()}}
\item \href{#method-SPDMatrices-inverse_differential_exp}{\code{SPDMatrices$inverse_differential_exp()}}
\item \href{#method-SPDMatrices-inverse_differential_log}{\code{SPDMatrices$inverse_differential_log()}}
\item \href{#method-SPDMatrices-inverse_differential_power}{\code{SPDMatrices$inverse_differential_power()}}
\item \href{#method-SPDMatrices-clone}{\code{SPDMatrices$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-new"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-new}{}}}
\subsection{Method \code{new()}}{
The \code{\link{SPDMatrices}} class constructor.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$new(n)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{An integer value representing the shape of the \verb{n x n} matrices.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{\link{SPDMatrices}} \link[R6:R6Class]{R6::R6Class} object.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  spdm
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-belongs"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-belongs}{}}}
\subsection{Method \code{belongs()}}{
Check if a matrix is symmetric with positive eigenvalues.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$belongs(mat, atol = 1e-12)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mat}}{A numeric matrix to be checked.}

\item{\code{atol}}{A numeric value specifying the absolute tolerance for
checking. Defaults to \code{1e-12}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A boolean that tells whether the input matrix is SPD.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  A <- diag(1, 3)
  spdm$belongs(A)
  B <- diag(-1, 3)
  spdm$belongs(B)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-cholesky_factor"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-cholesky_factor}{}}}
\subsection{Method \code{cholesky_factor()}}{
Computes Cholesky factor for a symmetric positive definite
matrix.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$cholesky_factor(mat)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mat}}{An SPD matrix.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The Cholesky factor represented as a numeric vector which stores
its lower triangular matrix including the diagonal elements in a
column-major fashion.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$cholesky_factor(A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-differential_cholesky_factor"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-differential_cholesky_factor}{}}}
\subsection{Method \code{differential_cholesky_factor()}}{
Computes the differential of the Cholesky factor map.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$differential_cholesky_factor(tangent_vec, base_point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tangent_vec}}{A symmetric matrix specifying the tangent vector at
base point.}

\item{\code{base_point}}{An SPD matrix specifying the base point.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The differential of the Cholesky factor map represented as a
numeric vector which stores its lower triangular matrix including the
diagonal elements in a column-major fashion.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_cholesky_factor(diag(1, 3), A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-differential_exp"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-differential_exp}{}}}
\subsection{Method \code{differential_exp()}}{
Computes the differential of the matrix exponential.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$differential_exp(tangent_vec, base_point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tangent_vec}}{A symmetric matrix specifying the tangent vector at
base point.}

\item{\code{base_point}}{An SPD matrix specifying the base point.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix storing the differential of the matrix exponential on
SPD matrices at \code{base_point} applied to \code{tangent_vec}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_exp(diag(1, 3), A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-differential_log"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-differential_log}{}}}
\subsection{Method \code{differential_log()}}{
Computes the differential of the matrix logarithm.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$differential_log(tangent_vec, base_point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tangent_vec}}{A symmetric matrix specifying the tangent vector at
base point.}

\item{\code{base_point}}{An SPD matrix specifying the base point.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix storing the differential of the matrix logarithm on
SPD matrices at \code{base_point} applied to \code{tangent_vec}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_log(diag(1, 3), A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-differential_power"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-differential_power}{}}}
\subsection{Method \code{differential_power()}}{
Computes the differential of the matrix power function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$differential_power(power, tangent_vec, base_point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{power}}{An integer scalar specifying the desired power.}

\item{\code{tangent_vec}}{A symmetric matrix specifying the tangent vector at
base point.}

\item{\code{base_point}}{An SPD matrix specifying the base point.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix storing the differential of the power function on
\eqn{\mathrm{SPD}(n)}: \deqn{A^p = \exp(p \log(A))} at \code{base_point}
applied to \code{tangent_vec}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_power(2, diag(1, 3), A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-expm"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-expm}{}}}
\subsection{Method \code{expm()}}{
Computes the matrix exponential for a symmetric matrix.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$expm(mat)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mat}}{A symmetric matrix.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An SPD matrix storing the exponential of the input symmetric
matrix \code{mat}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  spdm$expm(diag(-1, 3))
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-logm"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-logm}{}}}
\subsection{Method \code{logm()}}{
Computes the matrix logarithm of an SPD matrix.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$logm(mat)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mat}}{An SPD matrix.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A symmetric matrix storing the logarithm of the input symmetric
matrix \code{mat}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  spdm$logm(diag(1, 3))
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-inverse_differential_exp"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-inverse_differential_exp}{}}}
\subsection{Method \code{inverse_differential_exp()}}{
Computes the inverse of the differential of the matrix
exponential.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$inverse_differential_exp(tangent_vec, base_point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tangent_vec}}{A symmetric matrix specifying the tangent vector at
base point.}

\item{\code{base_point}}{An SPD matrix specifying the base point.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix storing the inverse of the differential of the matrix
exponential on SPD matrices at \code{base_point} applied to \code{tangent_vec}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$inverse_differential_exp(diag(1, 3), A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-inverse_differential_log"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-inverse_differential_log}{}}}
\subsection{Method \code{inverse_differential_log()}}{
Computes the inverse of the differential of the matrix
logarithm.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$inverse_differential_log(tangent_vec, base_point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tangent_vec}}{A symmetric matrix specifying the tangent vector at
base point.}

\item{\code{base_point}}{An SPD matrix specifying the base point.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix storing the inverse of the differential of the matrix
logarithm on SPD matrices at \code{base_point} applied to \code{tangent_vec}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$inverse_differential_log(diag(1, 3), A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-inverse_differential_power"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-inverse_differential_power}{}}}
\subsection{Method \code{inverse_differential_power()}}{
Computes the inverse of the differential of the matrix power
function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$inverse_differential_power(power, tangent_vec, base_point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{power}}{An integer scalar specifying the desired power.}

\item{\code{tangent_vec}}{A symmetric matrix specifying the tangent vector at
base point.}

\item{\code{base_point}}{An SPD matrix specifying the base point.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix storing the inversde of the differential of the power
function on \eqn{\mathrm{SPD}(n)}: \deqn{A^p = \exp(p \log(A))} at
\code{base_point} applied to \code{tangent_vec}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$inverse_differential_power(2, diag(1, 3), A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-clone"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
