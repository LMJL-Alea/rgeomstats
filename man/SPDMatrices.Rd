% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spd-matrices.R
\name{SPDMatrices}
\alias{SPDMatrices}
\title{Manifold of Symmetric Positive Definite Matrices}
\description{
Class for the manifold of symmetric positive definite (SPD)
matrices.
}
\examples{

## ------------------------------------------------
## Method `SPDMatrices$new`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  spdm
}

## ------------------------------------------------
## Method `SPDMatrices$belongs`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  A <- diag(1, 3)
  spdm$belongs(A)
  B <- diag(-1, 3)
  spdm$belongs(B)
}

## ------------------------------------------------
## Method `SPDMatrices$cholesky_factor`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$cholesky_factor(A)
}

## ------------------------------------------------
## Method `SPDMatrices$differential_cholesky_factor`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_cholesky_factor(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$differential_exp`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_exp(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$differential_log`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_log(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$differential_power`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_power(2, diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$expm`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  spdm$expm(diag(-1, 3))
}

## ------------------------------------------------
## Method `SPDMatrices$logm`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  spdm$logm(diag(1, 3))
}

## ------------------------------------------------
## Method `SPDMatrices$powerm`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$powerm(diag(1, 3), 2)
}

## ------------------------------------------------
## Method `SPDMatrices$inverse_differential_exp`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$inverse_differential_exp(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$inverse_differential_log`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$inverse_differential_log(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$inverse_differential_power`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$inverse_differential_power(2, diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$projection`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  A <- matrix(1:9, 3, 3)
  spdm$projection(A)
}

## ------------------------------------------------
## Method `SPDMatrices$random_point`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  # spdm$random_point(10) # TO DO: uncomment when bug fixed in gs
}

## ------------------------------------------------
## Method `SPDMatrices$random_tangent_vec`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  spdm$random_tangent_vec(diag(1, 3), 10)
}
}
\author{
Yann Thanwerdas
}
\concept{discretized curves space}
\section{Super class}{
\code{rgeomstats::PythonClass} -> \code{SPDMatrices}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-SPDMatrices-new}{\code{SPDMatrices$new()}}
\item \href{#method-SPDMatrices-belongs}{\code{SPDMatrices$belongs()}}
\item \href{#method-SPDMatrices-cholesky_factor}{\code{SPDMatrices$cholesky_factor()}}
\item \href{#method-SPDMatrices-differential_cholesky_factor}{\code{SPDMatrices$differential_cholesky_factor()}}
\item \href{#method-SPDMatrices-differential_exp}{\code{SPDMatrices$differential_exp()}}
\item \href{#method-SPDMatrices-differential_log}{\code{SPDMatrices$differential_log()}}
\item \href{#method-SPDMatrices-differential_power}{\code{SPDMatrices$differential_power()}}
\item \href{#method-SPDMatrices-expm}{\code{SPDMatrices$expm()}}
\item \href{#method-SPDMatrices-logm}{\code{SPDMatrices$logm()}}
\item \href{#method-SPDMatrices-powerm}{\code{SPDMatrices$powerm()}}
\item \href{#method-SPDMatrices-inverse_differential_exp}{\code{SPDMatrices$inverse_differential_exp()}}
\item \href{#method-SPDMatrices-inverse_differential_log}{\code{SPDMatrices$inverse_differential_log()}}
\item \href{#method-SPDMatrices-inverse_differential_power}{\code{SPDMatrices$inverse_differential_power()}}
\item \href{#method-SPDMatrices-projection}{\code{SPDMatrices$projection()}}
\item \href{#method-SPDMatrices-random_point}{\code{SPDMatrices$random_point()}}
\item \href{#method-SPDMatrices-random_tangent_vec}{\code{SPDMatrices$random_tangent_vec()}}
\item \href{#method-SPDMatrices-clone}{\code{SPDMatrices$clone()}}
}
}
\if{html}{\out{
<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
</ul>
</details>
}}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-new"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-new}{}}}
\subsection{Method \code{new()}}{
The \code{\link{SPDMatrices}} class constructor.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$new(n)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{An integer value representing the shape of the \verb{n x n} matrices.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{\link{SPDMatrices}} \link[R6:R6Class]{R6::R6Class} object.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  spdm
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-belongs"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-belongs}{}}}
\subsection{Method \code{belongs()}}{
Check if a matrix is symmetric with positive eigenvalues.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$belongs(mat, atol = 1e-12)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mat}}{A numeric matrix to be checked.}

\item{\code{atol}}{A numeric value specifying the absolute tolerance for
checking. Defaults to \code{1e-12}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A boolean that tells whether the input matrix is SPD.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  A <- diag(1, 3)
  spdm$belongs(A)
  B <- diag(-1, 3)
  spdm$belongs(B)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-cholesky_factor"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-cholesky_factor}{}}}
\subsection{Method \code{cholesky_factor()}}{
Computes Cholesky factor for a symmetric positive definite
matrix.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$cholesky_factor(mat)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mat}}{An SPD matrix.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The Cholesky factor represented as a numeric vector which stores
its lower triangular matrix including the diagonal elements in a
column-major fashion.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$cholesky_factor(A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-differential_cholesky_factor"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-differential_cholesky_factor}{}}}
\subsection{Method \code{differential_cholesky_factor()}}{
Computes the differential of the Cholesky factor map.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$differential_cholesky_factor(tangent_vec, base_point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tangent_vec}}{A symmetric matrix specifying the tangent vector at
base point.}

\item{\code{base_point}}{An SPD matrix specifying the base point.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The differential of the Cholesky factor map represented as a
numeric vector which stores its lower triangular matrix including the
diagonal elements in a column-major fashion.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_cholesky_factor(diag(1, 3), A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-differential_exp"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-differential_exp}{}}}
\subsection{Method \code{differential_exp()}}{
Computes the differential of the matrix exponential.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$differential_exp(tangent_vec, base_point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tangent_vec}}{A symmetric matrix specifying the tangent vector at
base point.}

\item{\code{base_point}}{An SPD matrix specifying the base point.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix storing the differential of the matrix exponential on
SPD matrices at \code{base_point} applied to \code{tangent_vec}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_exp(diag(1, 3), A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-differential_log"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-differential_log}{}}}
\subsection{Method \code{differential_log()}}{
Computes the differential of the matrix logarithm.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$differential_log(tangent_vec, base_point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tangent_vec}}{A symmetric matrix specifying the tangent vector at
base point.}

\item{\code{base_point}}{An SPD matrix specifying the base point.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix storing the differential of the matrix logarithm on
SPD matrices at \code{base_point} applied to \code{tangent_vec}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_log(diag(1, 3), A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-differential_power"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-differential_power}{}}}
\subsection{Method \code{differential_power()}}{
Computes the differential of the matrix power function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$differential_power(power, tangent_vec, base_point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{power}}{An integer scalar specifying the desired power.}

\item{\code{tangent_vec}}{A symmetric matrix specifying the tangent vector at
base point.}

\item{\code{base_point}}{An SPD matrix specifying the base point.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix storing the differential of the power function on
\eqn{\mathrm{SPD}(n)}: \deqn{A^p = \exp(p \log(A))} at \code{base_point}
applied to \code{tangent_vec}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$differential_power(2, diag(1, 3), A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-expm"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-expm}{}}}
\subsection{Method \code{expm()}}{
Computes the matrix exponential for a symmetric matrix.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$expm(mat)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mat}}{A symmetric matrix.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An SPD matrix storing the exponential of the input symmetric
matrix \code{mat}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  spdm$expm(diag(-1, 3))
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-logm"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-logm}{}}}
\subsection{Method \code{logm()}}{
Computes the matrix logarithm of an SPD matrix.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$logm(mat)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mat}}{An SPD matrix.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A symmetric matrix storing the logarithm of the input symmetric
matrix \code{mat}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  spdm$logm(diag(1, 3))
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-powerm"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-powerm}{}}}
\subsection{Method \code{powerm()}}{
Computes the matrix power of an SPD matrix.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$powerm(mat, power)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mat}}{An SPD matrix.}

\item{\code{power}}{A numeric scalar or vector specifying the desired power(s).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An SPD matrix representing the matrix power of the input matrix
as: \deqn{A^p = \exp(p \log(A)).} If \code{power} is a vector, a list of
such matrices elevated at the corresponding powers.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$powerm(diag(1, 3), 2)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-inverse_differential_exp"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-inverse_differential_exp}{}}}
\subsection{Method \code{inverse_differential_exp()}}{
Computes the inverse of the differential of the matrix
exponential.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$inverse_differential_exp(tangent_vec, base_point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tangent_vec}}{A symmetric matrix specifying the tangent vector at
base point.}

\item{\code{base_point}}{An SPD matrix specifying the base point.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix storing the inverse of the differential of the matrix
exponential on SPD matrices at \code{base_point} applied to \code{tangent_vec}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$inverse_differential_exp(diag(1, 3), A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-inverse_differential_log"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-inverse_differential_log}{}}}
\subsection{Method \code{inverse_differential_log()}}{
Computes the inverse of the differential of the matrix
logarithm.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$inverse_differential_log(tangent_vec, base_point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tangent_vec}}{A symmetric matrix specifying the tangent vector at
base point.}

\item{\code{base_point}}{An SPD matrix specifying the base point.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix storing the inverse of the differential of the matrix
logarithm on SPD matrices at \code{base_point} applied to \code{tangent_vec}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$inverse_differential_log(diag(1, 3), A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-inverse_differential_power"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-inverse_differential_power}{}}}
\subsection{Method \code{inverse_differential_power()}}{
Computes the inverse of the differential of the matrix power
function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$inverse_differential_power(power, tangent_vec, base_point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{power}}{An integer scalar specifying the desired power.}

\item{\code{tangent_vec}}{A symmetric matrix specifying the tangent vector at
base point.}

\item{\code{base_point}}{An SPD matrix specifying the base point.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix storing the inverse of the differential of the power
function on \eqn{\mathrm{SPD}(n)}: \deqn{A^p = \exp(p \log(A))} at
\code{base_point} applied to \code{tangent_vec}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  V <- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A <- V \%*\% diag(1:3) \%*\% t(V)
  spdm$inverse_differential_power(2, diag(1, 3), A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-projection"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-projection}{}}}
\subsection{Method \code{projection()}}{
Projects any square matrix to the space of SPD matrices.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$projection(point)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{point}}{A square matrix.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
First the symmetric part of point is computed, then the
eigenvalues are floored to \code{gs.atol}.
}

\subsection{Returns}{
An SPD matrix obtained by projecting the input square matrix onto
the space of SPD matrices.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  A <- matrix(1:9, 3, 3)
  spdm$projection(A)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-random_point"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-random_point}{}}}
\subsection{Method \code{random_point()}}{
Samples in \eqn{\mathrm{SPD}(n)} from the log-uniform
distribution.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$random_point(n_samples = 1, bound = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n_samples}}{An integer value specifying the sample size. Defaults to
\code{1L}.}

\item{\code{bound}}{A numeric value specifying the bound of the interval in
which to sample in the tangent space. Defaults to \code{1.0}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of SPD matrices sampled in \eqn{\mathrm{SPD}(n)}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  # spdm$random_point(10) # TO DO: uncomment when bug fixed in gs
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-random_tangent_vec"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-random_tangent_vec}{}}}
\subsection{Method \code{random_tangent_vec()}}{
Samples on the tangent space of \eqn{\mathrm{SPD}(n)} from
the uniform distribution.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$random_tangent_vec(base_point, n_samples = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{base_point}}{An SPD matrix specifying the base point.}

\item{\code{n_samples}}{An integer value specifying the sample size. Defaults to
\code{1L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of symmetric matrices sampled on the tangent space of
\eqn{\mathrm{SPD}(n)} at \code{base_point}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{if (reticulate::py_module_available("geomstats")) {
  spdm <- SPDMatrices$new(n = 3)
  spdm$random_tangent_vec(diag(1, 3), 10)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-SPDMatrices-clone"></a>}}
\if{latex}{\out{\hypertarget{method-SPDMatrices-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SPDMatrices$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
